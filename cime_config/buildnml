#!/usr/bin/env python3

"""DART Namelist creator.
"""

# Typically ignore this.
# pylint: disable=invalid-name

# Disable these because this is our standard setup
# pylint: disable=wildcard-import,unused-wildcard-import

import os, sys, shutil

_CIMEROOT = os.getenv("CIMEROOT")
sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))

from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, symlink_force
from CIME.buildnml import create_namelist_infile, parse_input

from CIME.ParamGen.paramgen_nml import ParamGen_NML

logger = logging.getLogger(__name__)

cesmtagmajor = "cesm2_1" # TODO: Generalize this!

def gen_DART_input_nml(case):

    class DART_input_nml(ParamGen_NML):
        def write(self, output_path, case):
            self.reduce(lambda varname: case.get_value(varname))
            self.write_nml(output_path)

    dartroot = case.get_value("COMP_ROOT_DIR_ESP")
    caseroot = case.get_value("CASEROOT")
    input_nml_template = os.path.join(dartroot, "param_templates", "json", "input_nml.json")
    input_nml = DART_input_nml.from_json(input_nml_template)

    user_nl_dart = ParamGen_NML.from_nml_file(os.path.join(caseroot,"user_nl_dart"))

    # loop over all variables in user_nl_dart. For variables with unspecified namelist groups,
    # determine their groups (if possible) and restore the accordingly
    if 'no_group' in user_nl_dart.data: 
        for var, values_dict in user_nl_dart.data['no_group'].items():
            val = values_dict['values']
            var_group = None
            for group in input_nml.data:
                if var in input_nml.data[group]:
                    expect(var_group is None, f"In user_nl_dart, cannot determine which namelist group the variable "
                                                f" {var} belongs to. (There are be multiple variables with the same "
                                                f"name that belongs to more than one namelist groups.)")
                    var_group = group
            expect(var_group is not None, f"In user_nl_dart, cannot determine which namelist group the variable "
                                        f" {var} belongs to. (No {var} was found in the default input.nml.")
            if var_group not in user_nl_dart.data:
                user_nl_dart.data[var_group] = {}
            user_nl_dart.data[var_group][var] = {'values': val}
    
        # drop 'no_group'. (All variables in 'no_group' are copied to their respective groups above.)
        user_nl_dart.data.pop('no_group')

    # apply user_nl changes to final input.nml
    if len(user_nl_dart.data)>0:
        input_nml.append(user_nl_dart)

    input_nml.write(os.path.join(caseroot,"input.nml"), case)

    return input_nml

def consistency_checks(case):
    calendar = case.get_value("CALENDAR")
    expect(calendar=="GREGORIAN", "When DART is active, the model calendar must be GREGORIAN.")

def stage_sampling_error_correction(case, data_assimilation, input_nml):

    caseroot = case.get_value("CASEROOT")
    dartroot = case.get_value("COMP_ROOT_DIR_ESP")
    rundir = case.get_value("RUNDIR")
    comp_ocn = case.get_value("COMP_OCN")

    n_da_comp = sum(data_assimilation.values())

    if data_assimilation['ocn'] is True:

        if comp_ocn == "pop":
            dart_model_dir = os.path.join(dartroot,"DART","models","POP")

            # assimilation script
            ninst_ocn = int(case.get_value('NINST_OCN'))
            assim_script = "assimilate.csh" if ninst_ocn>1 else "perfect_model.csh"
            shutil.copy(os.path.join(dart_model_dir, "shell_scripts", cesmtagmajor, assim_script), caseroot)
            case.set_value('DATA_ASSIMILATION_SCRIPT', os.path.join(caseroot, assim_script))

            # Stage the files needed for SAMPLING ERROR CORRECTION
            # -------------------------------------------------------------------------
            # TODO: copy below files to Buildconf/dartconf, and not to the caseroot
            sampling_error_correction = input_nml.data['assim_tools_nml']['sampling_error_correction']['values']
            if sampling_error_correction == '.true.':

                samp_err_file = os.path.join(dartroot, 'DART', 'assimilation_code', 'programs',
                                             'gen_sampling_err_table', 'work', 'sampling_error_correction_table.nc')
                if os.path.exists(samp_err_file):
                    expect(3<=ninst_ocn<=200, f"sampling_error_correction_table.nc handles ensemble sizes 3...200. "
                                              f"Yours is {ninst_ocn}.")
                    shutil.copy(samp_err_file, rundir)
                else: # sampling_error_correction_table.nc file found
                    expect(sampling_error_correction != '.true.', \
                        "No sampling_error_correction_table.nc file found...\n"
                        "The input.nml:assim_tool_nml:sampling_error_correction is .true. so this file must exist.")

        else:
            expect(False, "Unsupported OCN component for data assimilation")
    else:
        expect(n_da_comp==0, "Unsupported combination of DATA_ASSIMILATION flags")


# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
####################################################################################
def buildnml(case, caseroot, compname):
###############################################################################

    # Build the component namelist and required stream txt files
    if compname != "dart":
        raise AttributeError

    caseroot = case.get_value("CASEROOT")
    dartroot = case.get_value("COMP_ROOT_DIR_ESP")

    # DATA_ASSIMILATION flag for each component
    data_assimilation = {cc: case.get_value(f"DATA_ASSIMILATION_{cc.upper()}") \
                            for cc in ['atm', 'cpl', 'ocn', 'wav', 'glc', 'ice', 'rof', 'lnd'] }

    # Determine configuration directory
    confdir = os.path.join(caseroot,"Buildconf",compname + "conf")
    if not os.path.isdir(confdir):
        os.makedirs(confdir)

    # few consistency checks
    consistency_checks(case)

    # generate DART_input_nml
    input_nml = gen_DART_input_nml(case)

    # stage sampling error correction
    stage_sampling_error_correction(case, data_assimilation, input_nml)

    ### create symbolic link to modify_namelist_templates.py in caseroot
    ##todo mnt_path = os.path.join(caseroot, "modify_namelist_templates.py")
    ##todo if not os.path.islink(mnt_path):
    ##todo     symlink_force(os.path.join(dartroot,"cime_config", "modify_namelist_templates.py"), os.path.join(caseroot, "modify_namelist_templates.py"))


###############################################################################
def _main_func():
    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "dart")


if __name__ == "__main__":
    _main_func()
