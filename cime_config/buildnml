#!/usr/bin/env python3

"""DART Namelist creator.
"""

# Typically ignore this.
# pylint: disable=invalid-name

# Disable these because this is our standard setup
# pylint: disable=wildcard-import,unused-wildcard-import

import os, sys, shutil

_CIMEROOT = os.getenv("CIMEROOT")
sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))

from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, safe_copy
from CIME.buildnml import create_namelist_infile, parse_input

from CIME.ParamGen.paramgen_nml import ParamGen_NML

logger = logging.getLogger(__name__)

cesmtagmajor = "cesm2_1" # TODO: Generalize this!

def gen_DART_input_nml(case):

    class DART_input_nml(ParamGen_NML):
        def write(self, output_path, case):
            self.reduce(lambda varname: case.get_value(varname))
            self.write_nml(output_path)

    dartroot = case.get_value("COMP_ROOT_DIR_ESP")
    caseroot = case.get_value("CASEROOT")
    input_nml_template = os.path.join(dartroot, "param_templates", "json", "input_nml.json")
    input_nml = DART_input_nml.from_json(input_nml_template)

    user_nl_dart = ParamGen_NML.from_nml_file(os.path.join(caseroot,"user_nl_dart"))

    # loop over all variables in user_nl_dart. For variables with unspecified namelist groups,
    # determine their groups (if possible) and restore the accordingly
    if 'no_group' in user_nl_dart.data: 
        for var, val in user_nl_dart.data['no_group'].items():
            var_group = None
            for group in input_nml.data:
                if var in input_nml.data[group]:
                    expect(var_group is None, f"In user_nl_dart, cannot determine which namelist group the variable "
                                                f" {var} belongs to. (There are be multiple variables with the same "
                                                f"name that belongs to more than one namelist groups.)")
                    var_group = group
            expect(var_group is not None, f"In user_nl_dart, cannot determine which namelist group the variable "
                                        f" {var} belongs to. (No {var} was found in the default input.nml.")
            if var_group not in user_nl_dart.data:
                user_nl_dart.data[var_group] = {}
            user_nl_dart.data[var_group][var] = {'values': val}
    
        # drop 'no_group'. (All variables in 'no_group' are copied to their respective groups above.)
        user_nl_dart.data.pop('no_group')

    # apply user_nl changes to final input.nml
    if len(user_nl_dart.data)>0:
        input_nml.append(user_nl_dart)

    input_nml.write(os.path.join(caseroot,"input.nml"), case)

    return input_nml

def consistency_checks(case):
    calendar = case.get_value("CALENDAR")
    expect(calendar=="GREGORIAN", "When DART is active, the model calendar must be GREGORIAN.")

def stage_sampling_error_correction(case):

    caseroot = case.get_value("CASEROOT")
    dartroot = case.get_value("COMP_ROOT_DIR_ESP")
    comp_ocn = case.get_value("COMP_OCN")

    # DATA_ASSIMILATION flag for each component
    data_assimilation = {cc: case.get_value(f"DATA_ASSIMILATION_{cc.upper()}") \
                            for cc in ['atm', 'cpl', 'ocn', 'wav', 'glc', 'ice', 'rof', 'lnd'] }

    if data_assimilation['ocn'] is True:

        if comp_ocn == "pop":
            dart_model_dir = os.path.join(dartroot,"DART","models","POP")

            # Stage the files needed for SAMPLING ERROR CORRECTION
            # -------------------------------------------------------------------------
            # TODO: copy below files to Buildconf/dartconf, and not to the caseroot
            ninst_ocn = int(case.get_value('NINST_OCN'))
            assim_script = "assimilate.csh" if ninst_ocn>1 else "perfect_model.csh"
            shutil.copy(os.path.join(dart_model_dir, "shell_scripts", cesmtagmajor, assim_script), caseroot)
            case.set_value('DATA_ASSIMILATION_SCRIPT', os.path.join(caseroot, assim_script))

            samp_err_file = os.path.join(dartroot, 'DART', 'assimilation_code', 'programs',
                                         'gen_sampling_err_table', 'work', 'sampling_error_correction_table.nc')
            if os.path.exists(samp_err_file):
                expect(3<=ninst_ocn<=200, f"sampling_error_correction_table.nc handles ensemble sizes 3...200. "
                                          f"Yours is {ninst_ocn}.")
            #else: # sampling_error_correction_table.nc file found
            # TODO

        else:
            expect(False, "Unsupported OCN component for data assimilation")
    else:
        expect(False, "Unsupported combination of DATA_ASSIMILATION flags")


# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
####################################################################################
def buildnml(case, caseroot, compname):
###############################################################################

    # Build the component namelist and required stream txt files
    if compname != "dart":
        raise AttributeError

    cimeroot = case.get_value("CIMEROOT")
    srcroot  = case.get_value("SRCROOT")
    rundir   = case.get_value("RUNDIR")
    ninst    = case.get_value("NINST_ESP")

    # Determine configuration directory
    confdir = os.path.join(caseroot,"Buildconf",compname + "conf")
    if not os.path.isdir(confdir):
        os.makedirs(confdir)

    # few consistency checks
    consistency_checks(case)

    # generate DART_input_nml
    gen_DART_input_nml(case)

    # stage sampling error correction
    stage_sampling_error_correction(case)


###############################################################################
def _main_func():
    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "dart")


if __name__ == "__main__":
    _main_func()
